## Ch6
### 6.1
可以，但deleteMin不行。
### 6.2（重要）
a. 将这些元素一次一个insert。得到1 3 2 6 7 5 4 15 14 12 9 10 11 13 8.    
b. 将这些元素全部输入,最后进行buildHeap即下滤。得到
1 3 2 12 6 4 8 15 14 9 7 5 11 13 10.
### 6.3（重要）
记住deleteMin操作是将```array[1]=array[currentSize--]```之后再对```array[1]```进行下滤。
### 6.4
略。
### 6.5
略。
### 6.6
225
### 6.7（没看懂）
### 6.8
易证。
### 6.9（证明没看懂）
记住。
### 6.11（重要）
### 6.12（重要）
线性时间算法（即先读入，再上滤）在最坏情况下的输入，和在随机化输入的情况下都表现更好。

### 6.13（重要）
a. 原始的```deleteMin```是将```array[currentSize]```赋给```array[1]```，之后进行下滤。每下滤一次都要比较两次（左右子树比较一次，选择最小的。再和父节点比较一次）。   
而改进的则是，从上而下，选取最小的结点。一直到叶子结点。每次只比较1次。共logN次。之后再将这些选取的最小结点，进行二分搜索。把```array[currentSize]```的正确存放位置找到。     
b. 在a的基础上，我们不是选取最小的结点一直到叶子结点。而是停在在logN-loglogN处（这样已经花费了logN-loglogN次比较），在此处进行比较。   
若```array[currentSize]```大于此处的值，则向下走。用二分查找找（花费loglogN+logloglogN次）。那么这样共花费logN+logloglogN次比较。   
若小于此处的值，则向上走。用二分查找，则最多的比较次数为loglogN.那么加到一起最多为logN.   
所以最坏情况为前者。logN+logloglogN+O(1).    
c. 
>The bound can be improved to log N + log ∗N + O(1), where log ∗N is the inverse Ackerman function (see Chapter 8). This bound can be found in reference [17].    

### 6.14（重要）
父节点：eg:d为4的4叉堆。   

		      1
		   2 3 4 5
		6789 1011121314 14151617 18192021  

按照二叉堆的思路，我们```子节点/d```的下取整应该为父节点位置。但是这里6/4=1.5 9/4=2.25不都符合要求。所以我们理想中的结点位置i应该满足：假如父节点为2,则2*4=8. 3*4=12.即i应该为8 9 10 11.而非6 7 8 9.所以我们发现规律：   
子节点位置i ->  i+d-2 即满足要求。故父节点位置为：   
```[(i+d-2)/d]```下取整。   
同理：父节点位置为i,子节点位置为：  
```(i-1)*d+2...id+1```.   

### 6.15（重要）
a. 共O((M+dN)logN)，M次percolateUp，需要O(MlogN).N次deleteMin需要O(dNlogN)次。因为在deleteMin时候（即下滤）的时候，要在众子树中选取最小的并替换。所以每一次需要dN次操作。故O(dNlogN).    
b. d为2，则需要O((M+N)logN)
c. d=Θ(N)，则需要O(M+N²)
d. d=max(2,M/N)

### 6.16（重要）（链式二叉堆的访问）
**二叉堆的链式表示**，在位置i上的节点，比如：24，其二进制表示为```1 1000```。    那么我们从高位开始算起，      第2个有效数开始，即 1 **1**000.依次向后，同时从根节点开始，0则为走左子树，1则为走右子树。
     
		       1
		   2         3
		 4   5     6     7
		8 9 10 11 12 13 14 15  
i位11 即```1011```，那么``011```为左->右->右。   

### 6.17（重要）（链式二叉堆的合并）
a. 将一个负无穷大的节点作为根节点，其左右子树分别是这两个二叉堆，之后再```deleteMin()```即可。   
b. 同a，但要将较多节点的二叉堆作为左子树，较少的二叉堆作为右子树，再做```deleteMin()```即可。   

c. 将较大的二叉堆分成几个小的二叉堆。具体分法如下（假设l为大的二叉堆）：   
在**最左路径**上，去掉**2**个高度为```r-1```的二叉堆；再去掉**1**个高度为```r```，```r+1```,....```l-2```的二叉堆。   
之后再将这些取下来的二叉堆和rhs二叉堆进行合并：   
合并时用lhs二叉堆的左子路径上的节点代替a b中的负无穷大，进行**下滤操作**（答案给出还有进行deleteMin，我认为下滤即可否则这就和a b算法的合并结果不一致了），只有在两个二叉堆进行合并时，没有多余的最左路径的节点才进行**负无穷大加deleteMin**。   

### 6.18（很重要）（最大-最小堆）
**双端优先队列**
见```MyMinMaxHeap.h```

### 6.19（略）
### 6.20（重要）
容易出错，对于左式堆的定义的理解。
### 6.21
证明该定理是正确的，与4.20练习相似.
### 6.22
如果按降序插入元素，则形成由左子节点链组成的左侧堆。 这是最好的，因为正确的路径长度被最小化。   
### 6.23（重要）（左式堆的decreaseKey)
如果按照二叉堆的```decreaseKey```方法进行，倘若要操作的节点是在左侧较深处，那么上滤所需要的时间是很长并难以接受的（由于左式堆的特性）。   
更为合理的方式是通过```remove```和```insert```结合进行，首先```remove```掉所操作节点，```remove```即将该节点的左右子树重新合并，替换掉所操作节点，可能会出现高度不平衡，要进行交换。之后，再进行```insert```.    
具体操作见Chapter 11  

### 6.24（重要）（左式树的懒惰删除）
在```Finding Minmum Spnning Trees```论文讨论了懒惰删除。通常的想法是：   
如果根节点被标记了删除，则进行cleanup。即 将所有的节点进行前序遍历，将有删除标记的节点踢出去，剩下的节点放在队列中。之后，将队首的两个节点（或者左式堆）进行合并，合并的结果放在队末尾，同时把这两个节点（或左式堆）删除。依次进行，直到只剩下一个左式堆。即为所求。   
即   

		     1*
		  2*    3
		4  5*  6
	  7  8   

则队列为1* 2* 4 7 8 5* 3 6，即4 7 8 3 6.    
合并4 7： 8 3 6 （4/7）    
合并8 3： 6 （4/7）（3/8）   
合并6 （4/7）.......   
最终为： 
 
	 		3
		  4   8
		7  6    

详见```MyLeftistHeap.h```中```LazyDeleteMin```