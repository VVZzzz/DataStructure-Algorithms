## Ch6
### 6.11（重要）
### 6.12（重要）
线性时间算法（即先读入，再上滤）在最坏情况下的输入，和在随机化输入的情况下都表现更好。

### 6.13（重要）
a. 原始的```deleteMin```是将```array[currentSize]```赋给```array[1]```，之后进行下滤。每下滤一次都要比较两次（左右子树比较一次，选择最小的。再和父节点比较一次）。   
而改进的则是，从上而下，选取最小的结点。一直到叶子结点。每次只比较1次。共logN次。之后再将这些选取的最小结点，进行二分搜索。把```array[currentSize]```的正确存放位置找到。     
b. 在a的基础上，我们不是选取最小的结点一直到叶子结点。而是停在在logN-loglogN处（这样已经花费了logN-loglogN次比较），在此处进行比较。   
若```array[currentSize]```大于此处的值，则向下走。用二分查找找（花费loglogN+logloglogN次）。那么这样共花费logN+logloglogN次比较。   
若小于此处的值，则向上走。用二分查找，则最多的比较次数为loglogN.那么加到一起最多为logN.   
所以最坏情况为前者。logN+logloglogN+O(1).    
c. 
>The bound can be improved to log N + log ∗N + O(1), where log ∗N is the inverse Ackerman function (see Chapter 8). This bound can be found in reference [17].    

### 6.14（重要）
父节点：eg:d为4的4叉堆。   

		      1
		   2 3 4 5
		6789 1011121314 14151617 18192021  

按照二叉堆的思路，我们```子节点/d```的下取整应该为父节点位置。但是这里6/4=1.5 9/4=2.25不都符合要求。所以我们理想中的结点位置i应该满足：假如父节点为2,则2*4=8. 3*4=12.即i应该为8 9 10 11.而非6 7 8 9.所以我们发现规律：   
子节点位置i ->  i+d-2 即满足要求。故父节点位置为：   
```[(i+d-2)/d]```下取整。   
同理：父节点位置为i,子节点位置为：  
```(i-1)*d+2...id+1```.