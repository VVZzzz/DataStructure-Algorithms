# Chapter5 练习
--------------------------------------
### 5.1（重要）
a.分离链接   
![](https://i.imgur.com/3o4ztgC.png)  
b.线性探测   
![](https://i.imgur.com/6JiG4kS.png)   
c.平方探测    
![](https://i.imgur.com/tbqlxQi.png)   
d.双散列   
![](https://i.imgur.com/kwHyTHS.png)   
其中1989不能正确插入，因为候选位置都已经有元素了。   

### 5.2（重要）
a.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323->4344   
[13] 1989   
[17] 6173   
  
b.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323   
[13] 1989    
[14] 4344    
[17] 6173   

c.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323       
[13] 1989   
[16] 4344      
[17] 6173   

d.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323       
[13] 1989   
[15] 4344    
[17] 6173   

### 5.3  
略

### 5.4（重要）
设原表的大小为`N`,已插入的元素个数为`m`。则令`p=m/N`.所求的就是这个`p`到什么时候开始向“缩小表”或者“扩大表”进行`rehash`.    
我们知道，应该让`rehash`操作的次数越少越好，所以我们应该找到一个`p`。使得这两个`rehash`相同概率发生。       
假设`m`减少，`m/N`时开始缩小表，则得到新表为`m/(N/2)`即`2m/N`。也就是说这个新表删除`m`个元素，就会`rehash`。而新增`2N-2m`个元素，就会达到`2N/N`。同样此时会`rehash`。所以我们应该使得：   
`m=2N-2m`,立即得到`m/N=p=2/3`。所以结果为：当装填因子`λ<2/3`时，就要`rehash`。

### 5.5（重要）
注意这里和SeparateChain不一样，当一个元素设置为DELETED时，currentsize不减1.
这是因为探测散列必须执行懒惰删除，而只有当rehash的时候，这些deleted的元素才会真正的删除。currentsize表示的是已经在散列表中占据位置的元素个数。
同样，考察这个表是否为空isEmpty。也只能查看theLists中元素状态是否全部为false才可以。  
见```MyHashProbing.h```中的```isEmpty```.

### 5.6 
a.将```findPos()```中的```while(theLists[currPos]!=EMPTY&&...)``` 换为  
```while(theLists[currPos]==ACTIVE&&...)```即可。返回那些状态为```EMPTY```和```DELETED```的结点。   
b.当散列表中```DELETED```的节点较少，```ACTIVE```的节点较多。则查找时间较长，否则可以得到改进。

### 5.7
一个好的库的实现中,length应该为内联函数。

### 5.8（重要）
查看```散列总结.md```   
>单独的链接散列需要使用链接，这需要花费一些内存，以及在内存分配例程上实现调用的标准方法，这通常很昂贵。 线性探测很容易实现，但由于主要群集因负载因子增加而导致性能严重下降。 二次探测仅稍微难以实现，并且在实践中提供了良好的性能。 如果表是半空的，插入可能会失败，但这不太可能。
即使它是这样，这样的插入将是如此昂贵，以至于无关紧要，并且几乎肯定会指出散列函数的弱点。 双散列消除了主群集和辅助群集，但是第二散列函数的计算可能是昂贵的。 Gonnet和Baeza-Yates [8]比较了几种散列策略; 他们的结果表明二次探测是最快的方法。

### 5.9
冲突解决函数为```f(i)=i*r(hash(x))```.平方探测中的冲突解决函数为```f(i)=i^2```.对于平方探测，```f(i)=f(i-1)+2i-1```，即每次的步长为+1 +3 +5 +7...,他们的差是固定的这样会导致***二次聚集***.   
而```r(hash(x))```可以看做是生成一个伪随机，这样每次的步长都不一样，有效避免***二次聚集***.

### 5.10 （重要）
这是一个可以值得使用的架构。但是注意，当存储的第一次的散列值(不进行mod TableSize的)，小于等于**新表**的大小时候才可以保留，是有效的。否则要重新进行计算散列函数。  
（答案上为**旧表**的大小，认为有错）。

### 5.11（重要）
第二种方案即使用散列表，用```Ai*Xi```表示p1,```Bj*Yj```表示p2.那么散列表的key为0 1 2 3 ....M+N。在计算过程中将key为i+j的值+=Ai*Bj即可。   
若大约O(M+N)项，第一种方案快排需要O((M+N)log(M+N)).

### 5.12（此题有问题）
避免初始化即对于原来的```HashEntry```中的```EntryType```不进行初始化。而是添加一个成员变量 ```int wheretoStack```.当没有初始化时，wheretoStack的值不确定。插入新的元素，则将这个元素的哈希值对应的位置，压入栈。同时更新wheretoStack为对应在栈中的位置。   
那么这个时候我们通过检查```stack[wheretoStack]？=pos```并且```wheretoStack```是否有效来查看这个节点是否是```ACTIVE```.   
（总体的思路还是空间换时间）