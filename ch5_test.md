# Chapter5 练习
--------------------------------------
### 5.1（重要）
a.分离链接   
![](https://i.imgur.com/3o4ztgC.png)  
b.线性探测   
![](https://i.imgur.com/6JiG4kS.png)   
c.平方探测    
![](https://i.imgur.com/tbqlxQi.png)   
d.双散列   
![](https://i.imgur.com/kwHyTHS.png)   
其中1989不能正确插入，因为候选位置都已经有元素了。   

### 5.2（重要）
a.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323->4344   
[13] 1989   
[17] 6173   
  
b.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323   
[13] 1989    
[14] 4344    
[17] 6173   

c.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323       
[13] 1989   
[16] 4344      
[17] 6173   

d.    
[0]  4199   
[1]  4371   
[8]  9679  
[12] 1323       
[13] 1989   
[15] 4344    
[17] 6173   

### 5.3  
略

### 5.4（重要）
设原表的大小为`N`,已插入的元素个数为`m`。则令`p=m/N`.所求的就是这个`p`到什么时候开始向“缩小表”或者“扩大表”进行`rehash`.    
我们知道，应该让`rehash`操作的次数越少越好，所以我们应该找到一个`p`。使得这两个`rehash`相同概率发生。       
假设`m`减少，`m/N`时开始缩小表，则得到新表为`m/(N/2)`即`2m/N`。也就是说这个新表删除`m`个元素，就会`rehash`。而新增`2N-2m`个元素，就会达到`2N/N`。同样此时会`rehash`。所以我们应该使得：   
`m=2N-2m`,立即得到`m/N=p=2/3`。所以结果为：当装填因子`λ<2/3`时，就要`rehash`。

### 5.5（重要）
注意这里和SeparateChain不一样，当一个元素设置为DELETED时，currentsize不减1.
这是因为探测散列必须执行懒惰删除，而只有当rehash的时候，这些deleted的元素才会真正的删除。currentsize表示的是已经在散列表中占据位置的元素个数。
同样，考察这个表是否为空isEmpty。也只能查看theLists中元素状态是否全部为false才可以。  
见```MyHashProbing.h```中的```isEmpty```.

### 5.6（重要）
