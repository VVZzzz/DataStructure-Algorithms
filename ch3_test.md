# Chapter3练习
--------------------------------------
### 3.6 约瑟夫问题

- 问题描述：  
>编号为1,2,3...n的人一词围成一圈，从第k个人开始报数（从1开始），数到m的人退出。接着下一个人又从1开>始报数，数到m的人退出，以此类推。问：剩下的人的编号是多少？

>如：n=6,m=3,k=1
 原始序列： 1  2  3  4  5  6 ； 从编号1开始报数
 第一轮数完后的序列为：  1  2  4  5  ； 3、6出列——从编号1开始报数
 第二轮数完后的序列为：  1  2  5   ； 4出列——从编号5开始报数
 第三轮数完后的序列为：   1  5   ；   2 出列——从5开始报数
 第四轮数完后的序列为：   1  ；5 出列

> 所以，最后出列的编号为1.

- 求解思路：
	- 朴素思路：  
	将这n个人编为双向链表(c++中为list),我们知道n个人中只有一个人存活。故外部循环为n次。每循环1次，就有一个人出局。而对于内部循环，便是找到第m个那一个。找到后，将他erase掉，重新进入外部循环。在此注意，如果遇到list.end()，那么下一个应该是list.begin()。
	故：

			// 朴素算法时间复杂度为O(nm)
			void josephus_base(int n, int m) {
				int i, j, mPrime, numLeft;
				list<int> L;
				list<int>::iterator iter;
				cin >> n >> m;
				numLeft = n;
				mPrime = m % n;
				for (i =1 ; i <= n; i++)
					L.push_back(i);
				iter = L.begin();
				// Pass the potato
				for (i = 0; i < n; i++)
				{
					mPrime = mPrime % numLeft;
					for (j = 0; j < mPrime; j++)
					{
						iter++;
						if (iter == L.end())
							iter = L.begin();
					}
					cout<<*iter<<" ";
					iter= L.erase(iter);
					if (iter == L.end())
						iter = L.begin();
				}
				cout<<endl;
			}
 
	- 数学推导解法    
	这里有一个公式记住即可，如下(编号从0开始)   
```f(n,m)=(f(n-1,m) + m) mod n,f(1,m) = 0```    
	```f(n,k)```为n个人，编号为m的出局的最终结果。
	公式的证明推导，见[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)  

			//时间复杂度为O(n)
			//編號從0開始，也就是說如果編號從1開始結果要加1
			int josephus(int n, int k) { //非遞回版本
				int s = 0;
				for (int i = 2; i <= n; i++)
					s = (s + k) % i;
				return s;
			}

			int josephus_recur(int n, int k) { //递归版本
				return n > 1 ? (josephus_recur(n - 1, k) + k) % n : 0;
			}

	- 从上一方法推广    
	时间复杂度为O(klogn)，详见[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)

### 3.9 
对于vector,按照C++标准,对push_back,pop_back,insert或erase的调用将使所有的指向vector的迭代器失效(潜在生成废物的可能)。为什么？

答：对于C++的各个容器，在其添加和删除元素之后，其迭代器有的会失效。详细描述见```<<C++Primer>> P315```

### 3.18
思路如下：将Node类中添加一个bool成员，标志此结点是否活动，若活动则标志为true，否则为“废物”标志为false。  
通过erase方法，将该节点设置为false，在迭代器相应的方法中确定是否为“废物”。  
参见```MyList.h```  

### 3.19
如果对```List```类去掉```头结点```或者```尾结点```，那么在末端插入或者删除操作将会变成```O(N)```时间，```N```为链表元素个数。

### 3.20
a.优点是编码更简单，如果随后重新插入已删除的key（在同一位置），则可以节省时间。 缺点是它使用更多空间，因为每个单元需要一个额外的位（通常是一个字节），并且不释放未使用的单元。
b.参见```MyList.h```  

### 3.24  
可以在任何array中实现两个栈stack，其中一个stack从低地址向上增长，另一个从高地址向下增长。并且用一个bool数组标志某个单元是否可用。都用完了的话，就发出栈溢出声明。

### 3.25
a. 将目标栈设为E，我们将用两个普通栈S和M实现这个E栈。用普通栈S实现push和pop，用普通栈M实现findMin。即一直维护栈顶是最小值元素，且依次顺序递增。    
当```E.push(x)```时：总```S.push(x)```。对于M，如果```x≤M```的栈顶元素，那么```M.push(x)```。   
当```E.pop()```时: 总```S.pop()```。对于M，如果pop出的元素≤```M.top()```则M也pop()。

b.第七章定理,排序操作时间代价总会为Ω(NlogN).

### 3.26  
方法1：三个堆栈的最大长度固定，分别从0 1/3*n 2/3*n开始。但是这样有个缺点，倘若有一个栈长度用完了。那么这三个栈都无法正常工作了。空间利用率不够。  
 
方法2：有两个栈分别从低地址向上增长，从高地址向下增长。第三个栈从数组中间位置向任意方向增长。一旦中间的栈和其他任意一个栈相遇，则移动中间的栈。移动的策略为将第三个堆栈的中心移动至两个堆栈的top的中点位置。（答案给出的）。而这样的话，要移动全部元素，时间效率不高。有人想出，第三个堆栈的增长策略为:   
```| Elem 6 | Elem 4 | Elem 2 | Elem 0 | Elem 1 | Elem 3 | Elem 5 |```
这样减少和另外两个堆栈的碰撞概率，用这个公式```f[n_] := 1/4 ( (-1)^n (-1 + 2 n) + 1) + BS3 ```得到下一个元素的存储位置。
但这样带来的问题是操作不均匀了。     

详见[StackOverflow同样问题的讨论](https://stackoverflow.com/questions/4770627/how-to-implement-3-stacks-with-one-array)。   

### 3.30
a.b.参见ch3.hpp   
c.这遵循众所周知的统计定理。 有关参考资料，请参阅第11章中的Sleator和Tarjan的论文。
