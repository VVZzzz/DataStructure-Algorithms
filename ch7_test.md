##CH7  
### 7.1  
略   
### 7.2
O(N)
### 7.3 
交换```a[i] a[i+k]```，题中表明逆序会被去掉。即最少为1。
而对于```a[i+1].....a[i+k-1]```中每一个元素来说,交换```a[i] a[i+k]```最多会消除2个逆序,在加上本身```a[i] a[i+k]```的1个公```2(k-1)+1```个   
### 7.4 （重要)（谢尔排序）
origin:  9 8 7 6 5 4 3 2 1   
	7:2 1 7 6 5 4 3 9 8   
	3:2 1 4 3 5 7 6 9 8  
	1:1 2 3 4 5 6 7 8 9   

### 7.5 （重要）
用增量序列{1,2}时间为Θ(N^2).证明略  

### 7.6 
证明略 

### 7.7 
即在做谢尔排序时,做完k间隔排序后,再做h间隔排序。其结果依旧是k间隔排序的。  

### 7.8 
略.

### 7.9  
没想明白,已排序和反序的都为O(NlogN).

### 7.10 
（a）不，因为连续增量仍然可以共享一个共同因子。 一个例子是序列1,3,9,21,45，h (t + 1) = 2h (t) + 3。
（b）是的，因为连续的增量是相对素数。 运行时间变为O（N 3/2）。   

### 7.11 
建立最大堆之后：  
879，811，572，434，543，123，142，65，111，242，453，102   
之后将堆顶和末尾交换   
结果易得。   

### 7.12 7.13  (重要）（堆排序的最佳输入？）
堆排序在任何输入上使用至少（大致）N log N比较，因此没有特别好的输入。 这个界限很紧; 参见Schaeffer和Sedgewick撰写的论文[18]。 这个结果适用于几乎所有的heapsort变种，它们有不同的重排策略。 参见Y. Ding和M. A. Weiss，“Heapsort的最佳案例下限”，计算49（1992）。

### 7.14  
```heapSort(vector<T> &a, int low, int high);```  
此时比如原本为 0 1 2 3 4 5 6 7 8 9，现在只排序 4 5 6 7 8.要改变的地方为```leftChild(i)=2*i+1-low```,假设low为根的位置。   

### 7.15
略   

### 7.16（重要）（归并排序的非递归算法）  
见```MySort.h``` 

### 7.17 7.18  
对于归并排序,无论何种输入,merge步骤总需要Θ(N),故需要O(NlogN).

### 7.19 (快排)

### 7.20 (重要)
(a) O(NlogN)，因为枢纽元分割情况很好。    
(b) O(NlogN)，原因同上。    
(c) O(NlogN)，由于用三中值取枢纽元，发生最坏情况的可能性很小。

### 7.21（重要）（枢纽元的选取情况）
(a) 如果选择第一个元素作为枢轴，则运行时间在前两种情况下退化为二次。 对于随机输入，它仍然是O（N log N）。   
(b) 取前两个互异元素的较大值：结果分析同（a）    
(c) 如果选择了随机元素，那么运行时间是所有输入所期望的O（N log N），尽管如果出现非常差的随机数，则存在O（N 2）最坏情况。 然而，这种情况发生的可能性几乎可以忽略不计。 第10章讨论了随机哲学。   
(d) 取所有元素的平均值：这是一条危险的道路; 它取决于密钥的分布。对于许多分布，例如统一，性能平均为O（N log N）。 对于偏斜分布，例如输入{1,2,4,8,16,32,64，...。。 ，}枢轴将一直很糟糕，给出二次运行时间，与输入的顺序无关。    

### 7.22（重要）（快排时遇到和枢纽元相等的情况的处理）
(a) 停止交换：O(NlogN)  
(b) i,j不停止,需要哨兵来保证i j不越界,此时i最终会停到倒数第二个位置上，这样的话导致不平衡的递归，会花费O(N^2)  
(c) i停止,j不停止，这样同样会导致不平衡的递归，即quickSort(a,left,i);quickSort(a,i+1,right).此时的i会很靠近left,最终会花费O(N^2).  

### 7.24 （生成三数中值最坏情况的输入序列方法）
20, 3, 5, 7, 9, 11, 13, 15, 17, 19, 4, 10, 2, 12, 6, 14, 1, 16, 8, 18   

当N是偶数时，将此扩展为更大数的方法如下：第一个元素是N，中间是N - 1，最后一个是N - 2.奇数（除了1）按递减顺序写入 中心的左边。 通过从最右边的位置开始按顺序写入偶数，始终跳过一个可用的空槽，并在到达中心时回绕。 该方法需要O（N log N）时间来生成置换，但适用于手动计算。 通过反转快速排序的动作，可以在线性时间内生成排列。

### 7.25 7.26 （重要）（快速排序的非递归形式）
见```MySort.h```