##CH7  
### 7.1  
略   
### 7.2
O(N)
### 7.3 
交换```a[i] a[i+k]```，题中表明逆序会被去掉。即最少为1。
而对于```a[i+1].....a[i+k-1]```中每一个元素来说,交换```a[i] a[i+k]```最多会消除2个逆序,在加上本身```a[i] a[i+k]```的1个公```2(k-1)+1```个   
### 7.4 （重要)（谢尔排序）
origin:  9 8 7 6 5 4 3 2 1   
	7:2 1 7 6 5 4 3 9 8   
	3:2 1 4 3 5 7 6 9 8  
	1:1 2 3 4 5 6 7 8 9   

### 7.5 （重要）
用增量序列{1,2}时间为Θ(N^2).证明略  

### 7.6 
证明略 

### 7.7 
即在做谢尔排序时,做完k间隔排序后,再做h间隔排序。其结果依旧是k间隔排序的。  

### 7.8 
略.

### 7.9  
没想明白,已排序和反序的都为O(NlogN).

### 7.10 
（a）不，因为连续增量仍然可以共享一个共同因子。 一个例子是序列1,3,9,21,45，h (t + 1) = 2h (t) + 3。
（b）是的，因为连续的增量是相对素数。 运行时间变为O（N 3/2）。   

### 7.11 
建立最大堆之后：  
879，811，572，434，543，123，142，65，111，242，453，102   
之后将堆顶和末尾交换   
结果易得。   

### 7.12 7.13  (重要）（堆排序的最佳输入？）
堆排序在任何输入上使用至少（大致）N log N比较，因此没有特别好的输入。 这个界限很紧; 参见Schaeffer和Sedgewick撰写的论文[18]。 这个结果适用于几乎所有的heapsort变种，它们有不同的重排策略。 参见Y. Ding和M. A. Weiss，“Heapsort的最佳案例下限”，计算49（1992）。

### 7.14  
```heapSort(vector<T> &a, int low, int high);```  
此时比如原本为 0 1 2 3 4 5 6 7 8 9，现在只排序 4 5 6 7 8.要改变的地方为```leftChild(i)=2*i+1-low```,假设low为根的位置。   

### 7.15
略   

### 7.16（重要）（归并排序的非递归算法）  
见```MySort.h``` 

### 7.17 7.18  
对于归并排序,无论何种输入,merge步骤总需要Θ(N),故需要O(NlogN).

### 7.19 (快排)

### 7.20 (重要)
(a) O(NlogN)，因为枢纽元分割情况很好。    
(b) O(NlogN)，原因同上。    
(c) O(NlogN)，由于用三中值取枢纽元，发生最坏情况的可能性很小。

### 7.21（重要）（枢纽元的选取情况）
(a) 如果选择第一个元素作为枢轴，则运行时间在前两种情况下退化为二次。 对于随机输入，它仍然是O（N log N）。   
(b) 取前两个互异元素的较大值：结果分析同（a）    
(c) 如果选择了随机元素，那么运行时间是所有输入所期望的O（N log N），尽管如果出现非常差的随机数，则存在O（N 2）最坏情况。 然而，这种情况发生的可能性几乎可以忽略不计。 第10章讨论了随机哲学。   
(d) 取所有元素的平均值：这是一条危险的道路; 它取决于密钥的分布。对于许多分布，例如统一，性能平均为O（N log N）。 对于偏斜分布，例如输入{1,2,4,8,16,32,64，...。。 ，}枢轴将一直很糟糕，给出二次运行时间，与输入的顺序无关。    

### 7.22（重要）（快排时遇到和枢纽元相等的情况的处理）
(a) 停止交换：O(NlogN)  
(b) i,j不停止,需要哨兵来保证i j不越界,此时i最终会停到倒数第二个位置上，这样的话导致不平衡的递归，会花费O(N^2)  
(c) i停止,j不停止，这样同样会导致不平衡的递归，即quickSort(a,left,i);quickSort(a,i+1,right).此时的i会很靠近left,最终会花费O(N^2).  

### 7.24 （生成三数中值最坏情况的输入序列方法）
20, 3, 5, 7, 9, 11, 13, 15, 17, 19, 4, 10, 2, 12, 6, 14, 1, 16, 8, 18   

当N是偶数时，将此扩展为更大数的方法如下：第一个元素是N，中间是N - 1，最后一个是N - 2.奇数（除了1）按递减顺序写入 中心的左边。 通过从最右边的位置开始按顺序写入偶数，始终跳过一个可用的空槽，并在到达中心时回绕。 该方法需要O（N log N）时间来生成置换，但适用于手动计算。 通过反转快速排序的动作，可以在线性时间内生成排列。

### 7.25 7.26 （重要）（快速排序的非递归形式）
见```MySort.h```   

### 7.27 7.28 （对于快排和枢纽元选择的进一步分析）
见论文[14] [11]   

### 7.29
见```quickSelect.h```

### 7.30 
略

### 7.31（重要）
只有插入排序和归并排序是稳定的，可以使用标记原始位置的方法使每个方法都可以稳定。   

### 7.32 
d.对于归并排序，若元素个数为```f(N)``` 则时间为```O(f(N)logf(N))```.所以使```f(N)=O(n/logN)```即可满足要求。   

### 7.35 (重要） 
(a) 合并两个以排序的元素数为N的序列，共有A(2n,n)种方法。    
(b) 以上操作需要比较的次数的下界为：log(A(2n,n))次  
更一般的两个序列为M N，则需要log(A(M+N,N)比较  

### 7.36 
题中方法为 第一步至少需要3次比较，第二步至少需要3次，第三步由7.35b可知需要log(A(6,3))次，总共至少需要11次比较。   
若之排列A，需要3次比较，之后遍历B进行二分查找插入。则共需要3+log(3)+log(4)+log(5)次比较。   

### 7.37 （重要，线性时间的分数排序）
首先任意两个分数之差不超过1/(N+1)^2,所以我们可以重写分数为c/(N+1)^2+d,忽略d,以c为基数进行**基数排序**即可。      
.**理解**：通常的想法是通分为```N!```,但```N!```数字很大，且计算要O(N),所以我们可以令所有的分数都按```(N+1)^2```为分母表示，eg：3/7表示为分母为64，则为3*（64/7） / 64 ，即27/64+（3/7）/64，则c为27，d为3/7/64.显然每个d都很小，可以忽略不计。这样一来，可以用整数c表示每个分数，之后用基数排序即可。   

### 7.38  (重要）
见```MySort::mid_AUB()```

### 7.39  
此题比较有意思，一种巧妙的做法是，虚构一个```maybe```元素，假想```false```<```maybe```<```true```.```maybe```放在a[N].之后通过标准的quickSort().完成要求,且时间为O(N)

### 7.40  
同7.39，定义"mayFalse" "mayTrue"，进行两次O(N)的快排。
首先"false"<"mayFalse"<"maybe"，之后"maybe"<"maytrue"<"true"。完成要求

### 7.41 7.42 
**教材定理，任何基于比较的排序算法需要比较的次数为log(N!)(平均) （最坏情况为log(N!)上取整数).**

### 7.46 
a.时间为O(N^2)    
b.比如：10 9 8 7 6 5 4 3 2 1  
第一次分割后 2 3 4 1 **5** 7 8 9 10 6 
又回到了a情况，故仍是二次

### 7.48  
b.快排之后,i从头,j从尾开始,a[i]+a[j].若和小于sum，i++,大于sum j--.

### 7.50 
首先快排,之后伪代码如下：

			for(int i=0;i<a.size();i++){
			 temp=sum-a[i];
			 for(int j=0,k=a.size()-1;j!=k;){
			 if(a[j]+a[k]>temp)
			       --j;
			else if(a[j]+a[k]<temp)
			       ++i;
			else 
				   return i j k.
			}
			}
			return -1;   

### 7.52 
思路：磁带为T1 T2,T1 放 1 2 3  4 5 6（每一个代表一个顺串）T2为空。   
T1:1 2 3 4 5 6    
T2:   

T1:2 3 4 5 6    
T2:1   

T1: 3 4 5 6   
T2: (1 2)   

T1: 4 5 6   
T2: (1 2) 3   

T1: 5 6   
T2: (1 2) (3 4)  

T1:    
T2: (1 2) (3 4) (5 6)  
之后同样做法。进行归并排序即可。   

     

